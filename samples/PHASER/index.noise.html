<!doctype html>
<meta charset="utf-8">
<title>Noise Example</title>
<body>
<script src="phaser/phaser.js"></script>
<script src="../../dist/neutrinoparticles.js"></script>
<script src="../../dist-PHASER/neutrinoparticles.phaser.js"></script>
<script>

    //TODO { backgroundColor: 0x404040 })
  const game = new Phaser.Game(800, 600, Phaser.WEBGL, 'phaser-example', { preload: preload, create: create, update: update });
  let testEffect;

  let lastUpdateTime = 0;//Date.now();

  function preload() {

    //  You can fill the preloader with as many assets as your game requires

    //  Here we are loading an image. The first parameter is the unique
    //  string by which we'll identify the image later in our code.

    //  The second parameter is the URL of the image (relative)
    game.load.image('einstein', './assets/ra_einstein.png');
    game.load.image('phaser-logo', './assets/phaser-logo-small.png');
    //
    game.load.image('star_glow_white', './textures/star_glow_white.png');
  }

  function create() {

    //  This creates a simple sprite that is using our loaded image and
    //  displays it on-screen
    const s = game.add.sprite(80, 0, 'einstein');
    s.rotation = 0.14;

    initParticles();

    addLogo();

  }

  function initParticles(){

    const neutrinoContext = new PhaserNeutrinoContext(game.renderer, "export_js/", "textures/");

    const noiseGenerator = new neutrinoContext.neutrino.NoiseGenerator();
    while (!noiseGenerator.step()) { // approx. 5,000 steps
      // you can use 'noiseGenerator.progress' to get generating progress from 0.0 to 1.0
    }

    testEffect = new PhaserNeutrinoEffect(
      new PhaserNeutrinoEffectModel(neutrinoContext, "noise.js"),
      [0, 0, 0],
      game,
      0
    );

    function startAnimate(){
      lastUpdateTime = Date.now();
      //now add the PhaserNeutrinoEffect (testEffect) to the game
      game.stage.addChild(testEffect);
    }

    if (testEffect.isReady) {
      startAnimate();
    } else {
      testEffect.onReady.addOnce(startAnimate);
    }

  }

  function update(){
    if(lastUpdateTime > 0){
      let currentTime = Date.now();
      let elapsedSeconds = (currentTime - lastUpdateTime) / 1000;
      lastUpdateTime = currentTime;
      testEffect.rotation += elapsedSeconds * 45.0;
      testEffect.updateParticles(elapsedSeconds);
    }
  }

  function addLogo(){
    const baseX = 400;
    const sprite = game.add.sprite(baseX, 300, 'phaser-logo');
    sprite.anchor.set(0.5);
    //make the logo jiggle about
    let time = Date.now();
    let timeCount = 0;
    sprite.update = function(){
      const oldTime = time;
      time = Date.now();
      timeCount += (time - oldTime) * 0.01;
      sprite.rotation = Math.sin(timeCount) * 0.25;
      sprite.x = baseX + (Math.cos(timeCount / 4) * 60);
    }
  }

//  //Test that Pixi is working
//  console.log(PIXI);
//
//  var renderer = PIXI.autoDetectRenderer(800, 600, { backgroundColor: 0x404040 }); // default renderer (usualy WebGL)
//  //var renderer = new PIXI.CanvasRenderer(800, 600, { backgroundColor: 0x404040 });
//
//  document.body.appendChild(renderer.view);
//
//  var neutrinoPixi = new PIXINeutrinoContext(renderer);
//  neutrinoPixi.effectsBasePath = "export_js/";
//  neutrinoPixi.texturesBasePath = "textures/";
//
//  {
//    var noiseGenerator = new neutrinoPixi.neutrino.NoiseGenerator();
//    while (!noiseGenerator.step()) {
//      // you can use 'noiseGenerator.progress' to get generating progress from 0.0 to 1.0
//    }
//  }
//
//  var stage = new PIXI.Container();
//
//  var testModel = new PIXINeutrinoEffectModel(neutrinoPixi, "noise.js");
//  var testEffect = new PIXINeutrinoEffect(testModel, [400, 300, 0]);
//  stage.addChild(testEffect);
//
//  if (testEffect.ready()) {
//    animate();
//  } else {
//    testEffect.once('ready', animate);
//  }
//
//  var lastUpdateTime = null;
//
//  function animate() {
//    if (lastUpdateTime == null) {
//      lastUpdateTime = Date.now();
//    }
//
//    var currentTime = Date.now();
//    var elapsedTime = (currentTime - lastUpdateTime) / 1000;
//    lastUpdateTime = currentTime;
//
//    testEffect.update(elapsedTime > 1.0 ? 1.0 : elapsedTime);
//
//    // render the root container
//    renderer.render(stage);
//
//    requestAnimationFrame(animate);
//  }

</script>
</body>